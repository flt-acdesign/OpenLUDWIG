<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LUDWIG Post-Processing</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <style>
        body, html { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #222; user-select: none; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; outline: none; }

        #ui-container {
            position: absolute; top: 10px; left: 10px;
            background: rgba(40, 40, 45, 0.95); padding: 15px;
            border-radius: 6px; color: #ddd; z-index: 10;
            width: 290px; border: 1px solid #555;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            max-height: 92vh; overflow-y: auto;
        }

        h2 { margin: 0 0 10px 0; font-size: 15px; color: #fff; border-bottom: 1px solid #666; padding-bottom: 5px; }
        .section-title { font-size: 12px; font-weight: bold; color: #00d0ff; margin-top: 12px; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 0.5px; }
        .row { margin-bottom: 8px; font-size: 13px; display: flex; align-items: center; justify-content: space-between; }
        .key { color: #00d0ff; font-weight: bold; }

        input[type=file] { width: 100%; font-size: 12px; margin-bottom: 5px; color: #ccc; }
        input[type=range] { flex-grow: 1; margin: 0 5px; cursor: pointer; }
        input[type=number] { width: 65px; background: #333; border: 1px solid #555; color: #fff; padding: 2px 5px; border-radius: 4px; }
        select { width: 100%; background: #333; color: white; border: 1px solid #555; padding: 4px; border-radius: 4px; margin-bottom: 8px; }

        .slider-container { margin-bottom: 5px; }
        .slider-label { font-size: 11px; color: #aaa; display: flex; justify-content: space-between; }

        .radio-group { display: flex; gap: 10px; margin-bottom: 5px; }
        .checkbox-row { display: flex; align-items: center; font-size: 13px; margin-bottom: 5px; }
        .checkbox-row input { margin-right: 8px; }

        #stats { font-size: 11px; color: #aaa; margin-top: 10px; border-top: 1px solid #555; padding-top: 5px; line-height: 1.5; }

        #selectionBox {
            position: absolute;
            border: 1px solid #00d0ff;
            background-color: rgba(0, 208, 255, 0.1);
            display: none; pointer-events: none; z-index: 100;
        }

        /* Color bar */
        #colorBar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 400px; height: 50px; z-index: 10; pointer-events: none;
        }
        #colorBar canvas { width: 100%; height: 20px; border: 1px solid #666; border-radius: 3px; }
        .colorbar-labels { display: flex; justify-content: space-between; color: #ccc; font-size: 11px; margin-top: 2px; }
        .colorbar-title { text-align: center; color: #fff; font-size: 12px; font-weight: bold; margin-bottom: 2px; }

        /* Object filter */
        #objectFilterContainer { display: none; }
        #objectFilterContainer.visible { display: block; }
        .object-list { max-height: 100px; overflow-y: auto; background: #2a2a2e; border: 1px solid #555; border-radius: 4px; padding: 4px; margin-bottom: 5px; }
        .object-item { display: flex; align-items: center; padding: 3px 5px; font-size: 12px; cursor: pointer; border-radius: 3px; }
        .object-item:hover { background: #3a3a3e; }
        .object-item input { margin-right: 6px; cursor: pointer; }
        .object-item label { cursor: pointer; flex-grow: 1; }
        .object-item .obj-count { color: #888; font-size: 11px; margin-left: 5px; }
        .object-btns { display: flex; gap: 5px; margin-bottom: 5px; }
        .object-btns button {
            flex: 1; padding: 3px 6px; font-size: 11px; cursor: pointer;
            background: #444; color: #ccc; border: 1px solid #666; border-radius: 3px;
        }
        .object-btns button:hover { background: #555; color: #fff; }

        /* Collapsible sections */
        .collapse-header {
            display: flex; align-items: center; cursor: pointer; padding: 4px 0;
            border-bottom: 1px solid #444; margin-bottom: 5px;
        }
        .collapse-header:hover { color: #fff; }
        .collapse-arrow { margin-right: 6px; font-size: 10px; transition: transform 0.15s; display: inline-block; }
        .collapse-arrow.closed { transform: rotate(-90deg); }
        .collapse-body { overflow: hidden; }
        .collapse-body.hidden { display: none; }

        .file-label { font-size: 11px; color: #888; margin-bottom: 2px; }

        /* Legend swatches */
        .legend-swatch { display: inline-block; width: 12px; height: 12px; border-radius: 2px; margin-right: 5px; vertical-align: middle; }
    </style>
</head>
<body>

    <div id="selectionBox"></div>

    <div id="ui-container">
        <h2>LUDWIG Post-Processing</h2>

        <!-- FILE INPUTS -->
        <div class="file-label">Surface mesh (.lbmp):</div>
        <input type="file" id="fileInputLBMP" accept=".lbmp">
        <div class="file-label">Net forces (.csv):</div>
        <input type="file" id="fileInputCSV" accept=".csv">
        <div class="file-label">Nodal loads (.csv):</div>
        <input type="file" id="fileInputNodal" accept=".csv">

        <!-- OBJECT FILTER -->
        <div id="objectFilterContainer">
            <div class="section-title">Object Filter</div>
            <div class="object-btns">
                <button id="btnSelectAll">Select All</button>
                <button id="btnSelectNone">Select None</button>
            </div>
            <div class="object-list" id="objectList"></div>
        </div>

        <!-- SURFACE SECTION -->
        <div class="collapse-header" onclick="toggleSection('surfaceBody', this)">
            <span class="collapse-arrow" id="arrowSurface">&#9660;</span>
            <span class="section-title" style="margin:0">Surface Mesh</span>
        </div>
        <div class="collapse-body" id="surfaceBody">
            <div class="section-title" style="margin-top:2px">Color Field</div>
            <select id="fieldSelect">
                <option value="pressure" selected>Pressure (Pa)</option>
                <option value="cp">Cp (Pressure Coefficient)</option>
                <option value="shear">Shear Stress (Pa)</option>
            </select>

            <div class="section-title">Color Scale</div>
            <div class="row">
                <label>Min:</label>
                <input type="number" id="surfColorMin" step="any" value="0.0">
                <label>Max:</label>
                <input type="number" id="surfColorMax" step="any" value="1.0">
            </div>
            <div class="checkbox-row">
                <input type="checkbox" id="chkAutoScale" checked>
                <label for="chkAutoScale">Auto Scale</label>
            </div>
            <div class="checkbox-row">
                <input type="checkbox" id="chkSymmetric">
                <label for="chkSymmetric">Symmetric (&plusmn;max)</label>
            </div>

            <div class="section-title">Display</div>
            <div class="checkbox-row">
                <input type="checkbox" id="chkShowSurface" checked>
                <label for="chkShowSurface">Show Surface</label>
            </div>
            <div class="checkbox-row">
                <input type="checkbox" id="chkWireframe">
                <label for="chkWireframe">Show Wireframe</label>
            </div>
            <div class="checkbox-row">
                <input type="checkbox" id="chkBackface" checked>
                <label for="chkBackface">Double-sided</label>
            </div>
            <div class="row">
                <label>Lighting:</label>
                <input type="range" id="lightSlider" min="0" max="200" step="5" value="100">
            </div>
        </div>

        <!-- VECTORS SECTION -->
        <div class="collapse-header" onclick="toggleSection('vectorBody', this)">
            <span class="collapse-arrow" id="arrowVector">&#9660;</span>
            <span class="section-title" style="margin:0">Force Vectors</span>
        </div>
        <div class="collapse-body" id="vectorBody">
            <div class="checkbox-row">
                <input type="checkbox" id="chkShowNetForces" checked>
                <label for="chkShowNetForces"><span class="legend-swatch" style="background: linear-gradient(to right, #33ff88, #ff4444);"></span>Net Forces</label>
            </div>
            <div class="checkbox-row">
                <input type="checkbox" id="chkShowNodalLoads" checked>
                <label for="chkShowNodalLoads"><span class="legend-swatch" style="background: linear-gradient(to right, #ffaa33, #aa33ff);"></span>Nodal Loads</label>
            </div>

            <div class="section-title" style="margin-top:2px">Vector Length Scale</div>
            <div class="row">
                <input type="range" id="scaleSlider" min="0.1" max="10.0" step="0.1" value="1.0">
                <input type="number" id="scaleNumber" min="0.1" max="100.0" step="0.1" value="1.0">
            </div>
            <div class="radio-group row">
                <div><input type="radio" name="scaleMode" value="linear" checked id="rLin"><label for="rLin"> Linear</label></div>
                <div><input type="radio" name="scaleMode" value="log" id="rLog"><label for="rLog"> Log</label></div>
            </div>

            <div class="section-title">Vector Color Scale</div>
            <div class="row">
                <label>Min:</label>
                <input type="number" id="vecColorMin" step="0.1" value="0.0">
                <label>Max:</label>
                <input type="number" id="vecColorMax" step="0.1" value="1.0">
            </div>

            <div class="section-title">Point Size</div>
            <div class="row">
                <input type="range" id="pointSlider" min="0" max="20" step="1" value="3">
                <input type="number" id="pointNumber" min="0" max="50" step="1" value="3">
            </div>

            <div class="section-title">Slicer</div>
            <div class="checkbox-row">
                <input type="checkbox" id="chkShowPlanes">
                <label for="chkShowPlanes">Show Clipping Planes</label>
            </div>
            <label style="font-size:12px; color:#ccc;">Active Axis:</label>
            <select id="axisSelect">
                <option value="x">X Axis</option>
                <option value="y">Y Axis</option>
                <option value="z" selected>Z Axis (Height)</option>
            </select>
            <div class="slider-container">
                <div class="slider-label"><span>Min Clip</span> <span id="lblMin">0.00</span></div>
                <input type="range" id="sliceMin" min="0" max="1000" step="1" value="0">
            </div>
            <div class="slider-container">
                <div class="slider-label"><span>Max Clip</span> <span id="lblMax">100.00</span></div>
                <input type="range" id="sliceMax" min="0" max="1000" step="1" value="1000">
            </div>
        </div>

        <div id="stats">No files loaded.</div>

        <div style="margin-top:15px; font-size:11px; color:#bbb; line-height: 1.5;">
            <strong>Controls:</strong><br>
            <span class="key">Left Drag</span> : Rotate<br>
            <span class="key">Middle Drag</span> : Pan<br>
            <span class="key">Right Click</span> : Set Center<br>
            <span class="key">Shift + Left</span> : Zoom Window
        </div>
    </div>

    <!-- Color bar -->
    <div id="colorBar" style="display:none;">
        <div class="colorbar-title" id="colorBarTitle">Pressure (Pa)</div>
        <canvas id="colorBarCanvas" height="20"></canvas>
        <div class="colorbar-labels">
            <span id="cbLabelMin">0</span>
            <span id="cbLabelMid">0.5</span>
            <span id="cbLabelMax">1</span>
        </div>
    </div>

    <canvas id="renderCanvas"></canvas>

    <script>
        // =================================================================
        //  COLLAPSIBLE SECTIONS
        // =================================================================
        function toggleSection(bodyId, headerEl) {
            const body = document.getElementById(bodyId);
            const arrow = headerEl.querySelector('.collapse-arrow');
            body.classList.toggle('hidden');
            arrow.classList.toggle('closed');
        }

        // =================================================================
        //  1. SCENE SETUP
        // =================================================================
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true });
        const selectionBox = document.getElementById("selectionBox");
        canvas.oncontextmenu = e => e.preventDefault();

        // Meshes
        let surfaceMesh = null;
        let wireframeMesh = null;
        let netVectorMesh = null;
        let netPointsMesh = null;
        let nodalVectorMesh = null;
        let nodalPointsMesh = null;
        let pivotMarker = null;
        let minPlane = null;
        let maxPlane = null;
        let axesViewer = null;
        let light1 = null;
        let light2 = null;

        // Data stores
        let meshData = null;           // from .lbmp
        let rawNetVectors = [];        // net forces from CSV
        let rawNodalVectors = [];      // nodal loads from CSV
        let csvNetObjectNames = new Set();
        let csvNodalObjectNames = new Set();

        // Unified object filter
        let allObjectNames = new Set();
        let activeObjects = new Set();

        let bounds = { min: {x:0,y:0,z:0}, max: {x:1,y:1,z:1}, center: {x:0,y:0,z:0}, size: 1 };

        const createScene = function () {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.15, 0.15, 0.18, 1);

            const camera = new BABYLON.ArcRotateCamera("camera", 0, Math.PI / 3, 10, BABYLON.Vector3.Zero(), scene);
            camera.upVector = new BABYLON.Vector3(0, 0, 1);
            camera.inputs.clear();
            camera.inputs.addMouseWheel();
            camera.inputs.addPointers();
            camera.inputs.attached.pointers.buttons = [0, 1];
            camera.inputs.attached.pointers._panningMouseButton = 1;
            camera.attachControl(canvas, true, false, 1);
            camera._panningMouseButton = 1;
            camera.panningSensibility = 500;
            camera.angularSensibilityX = 1000;
            camera.angularSensibilityY = 1000;
            camera.wheelDeltaPercentage = 0.05;
            camera.lowerBetaLimit = null;
            camera.upperBetaLimit = null;
            camera.minZ = 0.01;

            light1 = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0.3, 0.3, 1), scene);
            light1.intensity = 0.7;
            light1.specular = new BABYLON.Color3(0.1, 0.1, 0.1);

            light2 = new BABYLON.DirectionalLight("light2", new BABYLON.Vector3(-0.5, -0.5, -0.3), scene);
            light2.intensity = 0.3;

            pivotMarker = BABYLON.MeshBuilder.CreateSphere("pivot", { diameter: 0.1 }, scene);
            const mat = new BABYLON.StandardMaterial("pivotMat", scene);
            mat.emissiveColor = new BABYLON.Color3(1, 0.6, 0);
            mat.disableLighting = true;
            pivotMarker.material = mat;
            pivotMarker.isVisible = false;
            pivotMarker.isPickable = false;

            // Slicing planes
            const planeMat = new BABYLON.StandardMaterial("planeMat", scene);
            planeMat.diffuseColor = new BABYLON.Color3(0, 0.8, 1);
            planeMat.alpha = 0.2;
            planeMat.backFaceCulling = false;
            planeMat.disableLighting = true;

            minPlane = BABYLON.MeshBuilder.CreatePlane("minPlane", { size: 1 }, scene);
            minPlane.material = planeMat;
            minPlane.isVisible = false;
            minPlane.isPickable = false;

            maxPlane = BABYLON.MeshBuilder.CreatePlane("maxPlane", { size: 1 }, scene);
            maxPlane.material = planeMat;
            maxPlane.isVisible = false;
            maxPlane.isPickable = false;

            return scene;
        };

        const scene = createScene();
        engine.runRenderLoop(() => scene.render());
        window.addEventListener("resize", () => engine.resize());

        // =================================================================
        //  2. UI ELEMENTS
        // =================================================================
        // Surface controls
        const fieldSelect = document.getElementById('fieldSelect');
        const surfColorMin = document.getElementById('surfColorMin');
        const surfColorMax = document.getElementById('surfColorMax');
        const chkAutoScale = document.getElementById('chkAutoScale');
        const chkSymmetric = document.getElementById('chkSymmetric');
        const chkShowSurface = document.getElementById('chkShowSurface');
        const chkWireframe = document.getElementById('chkWireframe');
        const chkBackface = document.getElementById('chkBackface');
        const lightSlider = document.getElementById('lightSlider');

        // Vector controls
        const chkShowNetForces = document.getElementById('chkShowNetForces');
        const chkShowNodalLoads = document.getElementById('chkShowNodalLoads');
        const scaleSlider = document.getElementById('scaleSlider');
        const scaleNumber = document.getElementById('scaleNumber');
        const radios = document.getElementsByName('scaleMode');
        const vecColorMin = document.getElementById('vecColorMin');
        const vecColorMax = document.getElementById('vecColorMax');
        const pointSlider = document.getElementById('pointSlider');
        const pointNumber = document.getElementById('pointNumber');
        const axisSelect = document.getElementById('axisSelect');
        const sliceMin = document.getElementById('sliceMin');
        const sliceMax = document.getElementById('sliceMax');
        const lblMin = document.getElementById('lblMin');
        const lblMax = document.getElementById('lblMax');
        const chkShowPlanes = document.getElementById('chkShowPlanes');

        const objectFilterContainer = document.getElementById('objectFilterContainer');
        const objectListDiv = document.getElementById('objectList');
        const btnSelectAll = document.getElementById('btnSelectAll');
        const btnSelectNone = document.getElementById('btnSelectNone');

        // Surface events
        fieldSelect.addEventListener('change', () => { surfAutoScale(); rebuildSurface(); });
        surfColorMin.addEventListener('input', () => { chkAutoScale.checked = false; rebuildSurface(); });
        surfColorMax.addEventListener('input', () => { chkAutoScale.checked = false; rebuildSurface(); });
        chkAutoScale.addEventListener('change', () => { if (chkAutoScale.checked) { surfAutoScale(); rebuildSurface(); } });
        chkSymmetric.addEventListener('change', () => { if (chkAutoScale.checked) surfAutoScale(); rebuildSurface(); });
        chkShowSurface.addEventListener('change', () => { rebuildSurface(); });
        chkWireframe.addEventListener('change', updateWireframe);
        chkBackface.addEventListener('change', updateBackface);
        lightSlider.addEventListener('input', updateLighting);

        // Vector events (shared controls affect both sets)
        chkShowNetForces.addEventListener('change', () => { rebuildAllVectors(); buildAllPoints(); });
        chkShowNodalLoads.addEventListener('change', () => { rebuildAllVectors(); buildAllPoints(); });
        scaleSlider.addEventListener('input', () => { scaleNumber.value = scaleSlider.value; rebuildAllVectors(); });
        scaleNumber.addEventListener('input', () => { scaleSlider.value = scaleNumber.value; rebuildAllVectors(); });
        radios.forEach(r => r.addEventListener('change', rebuildAllVectors));
        vecColorMin.addEventListener('input', rebuildAllVectors);
        vecColorMax.addEventListener('input', rebuildAllVectors);
        pointSlider.addEventListener('input', () => { pointNumber.value = pointSlider.value; updateAllPointSizes(); });
        pointNumber.addEventListener('input', () => { pointSlider.value = pointNumber.value; updateAllPointSizes(); });
        axisSelect.addEventListener('change', rebuildAllVectors);
        sliceMin.addEventListener('input', rebuildAllVectors);
        sliceMax.addEventListener('input', rebuildAllVectors);
        chkShowPlanes.addEventListener('change', rebuildAllVectors);

        // Object filter events
        btnSelectAll.addEventListener('click', () => {
            activeObjects = new Set(allObjectNames);
            updateObjectCheckboxes();
            onObjectFilterChanged();
        });
        btnSelectNone.addEventListener('click', () => {
            activeObjects.clear();
            updateObjectCheckboxes();
            onObjectFilterChanged();
        });

        function onObjectFilterChanged() {
            if (meshData) { surfAutoScale(); rebuildSurface(); }
            buildAllPoints();
            rebuildAllVectors();
            updateStats();
        }

        // Convenience wrappers
        function rebuildAllVectors() {
            rebuildVectors(rawNetVectors, 'net');
            rebuildVectors(rawNodalVectors, 'nodal');
            // Update slicer planes once
            const axis = axisSelect.value;
            const showPlanes = chkShowPlanes.checked;
            const dMin = bounds.min[axis];
            const dMax = bounds.max[axis];
            const dRange = dMax - dMin || 1;
            const userMin = (parseFloat(sliceMin.value) / 1000) * dRange + dMin;
            const userMax = (parseFloat(sliceMax.value) / 1000) * dRange + dMin;
            lblMin.innerText = userMin.toFixed(2);
            lblMax.innerText = userMax.toFixed(2);
            updateSlicerPlanes(axis, userMin, userMax, showPlanes);
        }

        function buildAllPoints() {
            buildStaticPoints(rawNetVectors, 'net');
            buildStaticPoints(rawNodalVectors, 'nodal');
        }

        function updateAllPointSizes() {
            const ps = parseFloat(pointNumber.value);
            if (netPointsMesh && netPointsMesh.material) netPointsMesh.material.pointSize = ps;
            if (nodalPointsMesh && nodalPointsMesh.material) nodalPointsMesh.material.pointSize = ps;
        }

        // =================================================================
        //  3. COLOR FUNCTIONS
        // =================================================================
        function getRainbow(t) {
            t = Math.max(0, Math.min(1, t));
            const hue = (1.0 - t) * 240;
            const c = 1.0;
            const x = c * (1 - Math.abs(((hue / 60) % 2) - 1));
            let r = 0, g = 0, b = 0;
            if (hue < 60)       { r = c; g = x; }
            else if (hue < 120) { r = x; g = c; }
            else if (hue < 180) { g = c; b = x; }
            else if (hue < 240) { g = x; b = c; }
            else if (hue < 300) { r = x; b = c; }
            else                { r = c; b = x; }
            return [r, g, b];
        }

        function getRainbowColor4(value, min, max) {
            let t = (max > min) ? (value - min) / (max - min) : 0;
            const [r, g, b] = getRainbow(t);
            return new BABYLON.Color4(r, g, b, 1);
        }

        function drawColorBar(cMin, cMax, label) {
            const bar = document.getElementById('colorBar');
            bar.style.display = 'block';
            const cvs = document.getElementById('colorBarCanvas');
            const ctx = cvs.getContext('2d');
            cvs.width = 400;
            const w = cvs.width, h = cvs.height;
            for (let i = 0; i < w; i++) {
                const t = i / (w - 1);
                const [r, g, b] = getRainbow(t);
                ctx.fillStyle = `rgb(${r * 255 | 0},${g * 255 | 0},${b * 255 | 0})`;
                ctx.fillRect(i, 0, 1, h);
            }
            document.getElementById('colorBarTitle').textContent = label;
            document.getElementById('cbLabelMin').textContent = cMin.toExponential(2);
            document.getElementById('cbLabelMid').textContent = ((cMin + cMax) / 2).toExponential(2);
            document.getElementById('cbLabelMax').textContent = cMax.toExponential(2);
        }

        // =================================================================
        //  4A. BINARY FILE PARSER (.lbmp)
        // =================================================================
        document.getElementById('fileInputLBMP').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => parseLBMP(ev.target.result);
            reader.readAsArrayBuffer(file);
        });

        function parseLBMP(buffer) {
            const view = new DataView(buffer);
            let off = 0;

            const magic = String.fromCharCode(view.getUint8(0), view.getUint8(1), view.getUint8(2), view.getUint8(3));
            if (magic !== 'LBMP') {
                document.getElementById('stats').textContent = 'Error: Not a valid .lbmp file';
                return;
            }
            off = 4;

            const version = view.getUint32(off, true); off += 4;
            const n_tri = view.getUint32(off, true); off += 4;
            const n_objects = view.getUint32(off, true); off += 4;

            const objectNames = [];
            for (let i = 0; i < n_objects; i++) {
                const nameLen = view.getUint32(off, true); off += 4;
                let name = '';
                for (let j = 0; j < nameLen; j++) name += String.fromCharCode(view.getUint8(off + j));
                off += nameLen;
                objectNames.push(name);
            }

            // Read typed arrays via DataView to handle unaligned offsets
            function readFloat32Array(view, offset, count) {
                const arr = new Float32Array(count);
                for (let i = 0; i < count; i++) { arr[i] = view.getFloat32(offset + i * 4, true); }
                return arr;
            }
            function readInt32Array(view, offset, count) {
                const arr = new Int32Array(count);
                for (let i = 0; i < count; i++) { arr[i] = view.getInt32(offset + i * 4, true); }
                return arr;
            }

            const vertices  = readFloat32Array(view, off, n_tri * 9); off += n_tri * 9 * 4;
            const normals   = readFloat32Array(view, off, n_tri * 3); off += n_tri * 3 * 4;
            const pressure  = readFloat32Array(view, off, n_tri);     off += n_tri * 4;
            const shear     = readFloat32Array(view, off, n_tri);     off += n_tri * 4;
            const cp        = readFloat32Array(view, off, n_tri);     off += n_tri * 4;
            const objectIds = readInt32Array(view, off, n_tri);       off += n_tri * 4;

            meshData = { n_tri, n_objects, objectNames, vertices, normals, pressure, shear, cp, objectIds, version };

            for (const n of objectNames) allObjectNames.add(n);
            activeObjects = new Set(allObjectNames);

            updateBounds();
            buildObjectFilterUI();
            frameCamera();
            surfAutoScale();
            rebuildSurface();
            updateStats();
        }

        // =================================================================
        //  4B. CSV PARSER â€” generic (used for both net forces + nodal loads)
        // =================================================================
        function parseForceCSV(text) {
            const vectors = [];
            const objectNames = new Set();
            const rows = text.split(/\r?\n/);

            const header = rows[0] ? rows[0].trim().toLowerCase() : "";
            const hasObjectName = header.includes("object_name");

            let minMag = Infinity, maxMag = -Infinity;

            for (let i = 1; i < rows.length; i++) {
                const r = rows[i].trim();
                if (!r) continue;
                const c = r.split(',');

                let objName, cx, cy, cz, Fx, Fy, Fz;
                if (hasObjectName) {
                    if (c.length < 8) continue;
                    objName = c[1].trim();
                    cx = parseFloat(c[2]); cy = parseFloat(c[3]); cz = parseFloat(c[4]);
                    Fx = parseFloat(c[5]); Fy = parseFloat(c[6]); Fz = parseFloat(c[7]);
                } else {
                    if (c.length < 7) continue;
                    objName = "default";
                    cx = parseFloat(c[1]); cy = parseFloat(c[2]); cz = parseFloat(c[3]);
                    Fx = parseFloat(c[4]); Fy = parseFloat(c[5]); Fz = parseFloat(c[6]);
                }
                if (isNaN(cx)) continue;

                objectNames.add(objName);

                const pos = new BABYLON.Vector3(cx, cy, cz);
                const vec = new BABYLON.Vector3(Fx, Fy, Fz);
                const mag = vec.length();
                if (mag < minMag) minMag = mag;
                if (mag > maxMag) maxMag = mag;
                const dir = mag > 0 ? vec.scale(1 / mag) : BABYLON.Vector3.Zero();
                vectors.push({ pos, dir, mag, obj: objName });
            }

            return { vectors, objectNames, minMag, maxMag };
        }

        // Net forces CSV input
        document.getElementById('fileInputCSV').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                const result = parseForceCSV(ev.target.result);
                rawNetVectors = result.vectors;
                csvNetObjectNames = result.objectNames;

                if (rawNetVectors.length === 0) {
                    document.getElementById('stats').textContent = "Error: No vector data in net forces CSV.";
                    return;
                }

                // Update color range from whichever has more extreme magnitudes
                autoUpdateVecColorRange();

                for (const n of csvNetObjectNames) allObjectNames.add(n);
                activeObjects = new Set(allObjectNames);

                updateBounds();
                buildObjectFilterUI();
                frameCamera();
                buildAllPoints();
                rebuildAllVectors();
                updateStats();
            };
            reader.readAsText(file);
        });

        // Nodal loads CSV input
        document.getElementById('fileInputNodal').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                const result = parseForceCSV(ev.target.result);
                rawNodalVectors = result.vectors;
                csvNodalObjectNames = result.objectNames;

                if (rawNodalVectors.length === 0) {
                    document.getElementById('stats').textContent = "Error: No vector data in nodal loads CSV.";
                    return;
                }

                autoUpdateVecColorRange();

                for (const n of csvNodalObjectNames) allObjectNames.add(n);
                activeObjects = new Set(allObjectNames);

                updateBounds();
                buildObjectFilterUI();
                frameCamera();
                buildAllPoints();
                rebuildAllVectors();
                updateStats();
            };
            reader.readAsText(file);
        });

        // Auto-set vector color range based on both datasets
        function autoUpdateVecColorRange() {
            let minMag = Infinity, maxMag = -Infinity;
            for (const v of rawNetVectors) {
                if (v.mag < minMag) minMag = v.mag;
                if (v.mag > maxMag) maxMag = v.mag;
            }
            for (const v of rawNodalVectors) {
                if (v.mag < minMag) minMag = v.mag;
                if (v.mag > maxMag) maxMag = v.mag;
            }
            if (minMag !== Infinity) {
                vecColorMin.value = minMag.toFixed(2);
                vecColorMax.value = maxMag.toFixed(2);
            }
        }

        // =================================================================
        //  5. BOUNDS, CAMERA, AXES
        // =================================================================
        function updateBounds() {
            let minX = Infinity, minY = Infinity, minZ = Infinity;
            let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

            if (meshData) {
                for (let i = 0; i < meshData.n_tri; i++) {
                    for (let v = 0; v < 3; v++) {
                        const base = i * 9 + v * 3;
                        const x = meshData.vertices[base], y = meshData.vertices[base + 1], z = meshData.vertices[base + 2];
                        if (x < minX) minX = x; if (x > maxX) maxX = x;
                        if (y < minY) minY = y; if (y > maxY) maxY = y;
                        if (z < minZ) minZ = z; if (z > maxZ) maxZ = z;
                    }
                }
            }
            for (const v of rawNetVectors) {
                if (v.pos.x < minX) minX = v.pos.x; if (v.pos.x > maxX) maxX = v.pos.x;
                if (v.pos.y < minY) minY = v.pos.y; if (v.pos.y > maxY) maxY = v.pos.y;
                if (v.pos.z < minZ) minZ = v.pos.z; if (v.pos.z > maxZ) maxZ = v.pos.z;
            }
            for (const v of rawNodalVectors) {
                if (v.pos.x < minX) minX = v.pos.x; if (v.pos.x > maxX) maxX = v.pos.x;
                if (v.pos.y < minY) minY = v.pos.y; if (v.pos.y > maxY) maxY = v.pos.y;
                if (v.pos.z < minZ) minZ = v.pos.z; if (v.pos.z > maxZ) maxZ = v.pos.z;
            }

            if (minX === Infinity) return;
            bounds.min = { x: minX, y: minY, z: minZ };
            bounds.max = { x: maxX, y: maxY, z: maxZ };
            bounds.center = { x: (minX + maxX) / 2, y: (minY + maxY) / 2, z: (minZ + maxZ) / 2 };
            bounds.size = Math.sqrt((maxX - minX) ** 2 + (maxY - minY) ** 2 + (maxZ - minZ) ** 2);
        }

        function frameCamera() {
            if (axesViewer) axesViewer.dispose();
            axesViewer = new BABYLON.AxesViewer(scene, bounds.size * 0.15);

            const center = new BABYLON.Vector3(bounds.center.x, bounds.center.y, bounds.center.z);
            scene.activeCamera.setTarget(center);
            scene.activeCamera.radius = bounds.size * 1.2;
            scene.activeCamera.minZ = bounds.size * 0.001;
            scene.activeCamera.panningSensibility = 2000 / (bounds.size || 1);
        }

        // =================================================================
        //  6. OBJECT FILTER (unified for surface + both vector sets)
        // =================================================================
        function buildObjectFilterUI() {
            objectListDiv.innerHTML = '';

            if (allObjectNames.size <= 1) {
                objectFilterContainer.classList.remove('visible');
                return;
            }
            objectFilterContainer.classList.add('visible');

            // Count triangles per object from surface data
            const counts = {};
            if (meshData) {
                for (let i = 0; i < meshData.n_tri; i++) {
                    const name = meshData.objectNames[meshData.objectIds[i] - 1];
                    counts[name] = (counts[name] || 0) + 1;
                }
            }

            const sorted = Array.from(allObjectNames).sort();
            for (const name of sorted) {
                const count = counts[name] || 0;
                const item = document.createElement('div');
                item.className = 'object-item';

                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.id = 'obj_' + name;
                cb.checked = activeObjects.has(name);
                cb.addEventListener('change', () => {
                    if (cb.checked) activeObjects.add(name); else activeObjects.delete(name);
                    onObjectFilterChanged();
                });

                const lbl = document.createElement('label');
                lbl.htmlFor = cb.id;
                lbl.textContent = name;

                const cs = document.createElement('span');
                cs.className = 'obj-count';
                cs.textContent = count > 0 ? `(${count.toLocaleString()})` : '';

                item.appendChild(cb);
                item.appendChild(lbl);
                item.appendChild(cs);
                objectListDiv.appendChild(item);
            }
        }

        function updateObjectCheckboxes() {
            const cbs = objectListDiv.querySelectorAll('input[type=checkbox]');
            for (const cb of cbs) cb.checked = activeObjects.has(cb.id.replace('obj_', ''));
        }

        // =================================================================
        //  7. SURFACE MESH BUILDER
        // =================================================================
        function getActiveField() {
            if (!meshData) return null;
            const f = fieldSelect.value;
            if (f === 'pressure') return meshData.pressure;
            if (f === 'cp') return meshData.cp;
            if (f === 'shear') return meshData.shear;
            return meshData.pressure;
        }

        function getFieldLabel() {
            const f = fieldSelect.value;
            if (f === 'pressure') return 'Pressure (Pa)';
            if (f === 'cp') return 'Cp';
            if (f === 'shear') return 'Shear Stress (Pa)';
            return 'Pressure (Pa)';
        }

        function surfAutoScale() {
            if (!meshData || !chkAutoScale.checked) return;
            const fieldArr = getActiveField();
            let mn = Infinity, mx = -Infinity;
            for (let i = 0; i < meshData.n_tri; i++) {
                const objName = meshData.objectNames[meshData.objectIds[i] - 1];
                if (!activeObjects.has(objName)) continue;
                const val = fieldArr[i];
                if (val < mn) mn = val;
                if (val > mx) mx = val;
            }
            if (mn === Infinity) { mn = 0; mx = 1; }
            if (chkSymmetric.checked) {
                const absMax = Math.max(Math.abs(mn), Math.abs(mx));
                mn = -absMax; mx = absMax;
            }
            surfColorMin.value = mn.toExponential(3);
            surfColorMax.value = mx.toExponential(3);
        }

        function rebuildSurface() {
            if (surfaceMesh) { surfaceMesh.dispose(); surfaceMesh = null; }
            if (wireframeMesh) { wireframeMesh.dispose(); wireframeMesh = null; }
            if (!meshData) return;

            const showSurf = chkShowSurface.checked;

            const fieldArr = getActiveField();
            const cMin = parseFloat(surfColorMin.value);
            const cMax = parseFloat(surfColorMax.value);
            const cRange = cMax - cMin;

            drawColorBar(cMin, cMax, getFieldLabel());

            if (!showSurf) return;

            let activeTris = 0;
            for (let i = 0; i < meshData.n_tri; i++) {
                const objName = meshData.objectNames[meshData.objectIds[i] - 1];
                if (activeObjects.has(objName)) activeTris++;
            }
            if (activeTris === 0) return;

            const positions = new Float32Array(activeTris * 9);
            const indices = new Uint32Array(activeTris * 3);
            const colorsRGBA = new Float32Array(activeTris * 12);
            const meshNormals = new Float32Array(activeTris * 9);

            let triIdx = 0;
            for (let i = 0; i < meshData.n_tri; i++) {
                const objName = meshData.objectNames[meshData.objectIds[i] - 1];
                if (!activeObjects.has(objName)) continue;

                const vBase = i * 9;
                const nBase = i * 3;
                const pBase = triIdx * 9;
                const iBase = triIdx * 3;
                const cBase = triIdx * 12;

                for (let k = 0; k < 9; k++) positions[pBase + k] = meshData.vertices[vBase + k];

                const vertOff = triIdx * 3;
                indices[iBase] = vertOff;
                indices[iBase + 1] = vertOff + 1;
                indices[iBase + 2] = vertOff + 2;

                const nx = meshData.normals[nBase];
                const ny = meshData.normals[nBase + 1];
                const nz = meshData.normals[nBase + 2];
                for (let v = 0; v < 3; v++) {
                    meshNormals[pBase + v * 3] = nx;
                    meshNormals[pBase + v * 3 + 1] = ny;
                    meshNormals[pBase + v * 3 + 2] = nz;
                }

                const val = fieldArr[i];
                const t = cRange > 0 ? (val - cMin) / cRange : 0.5;
                const [r, g, b] = getRainbow(t);
                for (let v = 0; v < 3; v++) {
                    colorsRGBA[cBase + v * 4] = r;
                    colorsRGBA[cBase + v * 4 + 1] = g;
                    colorsRGBA[cBase + v * 4 + 2] = b;
                    colorsRGBA[cBase + v * 4 + 3] = 1.0;
                }
                triIdx++;
            }

            surfaceMesh = new BABYLON.Mesh("surface", scene);
            const vertexData = new BABYLON.VertexData();
            vertexData.positions = positions;
            vertexData.indices = indices;
            vertexData.normals = meshNormals;
            vertexData.colors = colorsRGBA;
            vertexData.applyToMesh(surfaceMesh);

            const mat = new BABYLON.StandardMaterial("surfMat", scene);
            mat.backFaceCulling = !chkBackface.checked;
            mat.diffuseColor = new BABYLON.Color3(1, 1, 1);
            mat.specularColor = new BABYLON.Color3(0.15, 0.15, 0.15);
            mat.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            surfaceMesh.material = mat;
            surfaceMesh.isPickable = true;

            if (chkWireframe.checked) {
                wireframeMesh = surfaceMesh.clone("wireframe");
                const wMat = new BABYLON.StandardMaterial("wireMat", scene);
                wMat.wireframe = true;
                wMat.emissiveColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                wMat.disableLighting = true;
                wMat.backFaceCulling = false;
                wireframeMesh.material = wMat;
                wireframeMesh.isPickable = false;
            }
        }

        function updateWireframe() {
            if (wireframeMesh) { wireframeMesh.dispose(); wireframeMesh = null; }
            if (chkWireframe.checked && surfaceMesh) {
                wireframeMesh = surfaceMesh.clone("wireframe");
                const wMat = new BABYLON.StandardMaterial("wireMat", scene);
                wMat.wireframe = true;
                wMat.emissiveColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                wMat.disableLighting = true;
                wMat.backFaceCulling = false;
                wireframeMesh.material = wMat;
                wireframeMesh.isPickable = false;
            }
        }

        function updateBackface() {
            if (surfaceMesh && surfaceMesh.material)
                surfaceMesh.material.backFaceCulling = !chkBackface.checked;
        }

        function updateLighting() {
            const intensity = parseFloat(lightSlider.value) / 100;
            if (light1) light1.intensity = intensity * 0.7;
            if (light2) light2.intensity = intensity * 0.3;
        }

        // =================================================================
        //  8. FORCE VECTOR BUILDER (generic for both net + nodal)
        // =================================================================
        // Color themes for each vector set
        const NET_ORIGIN_COLOR = new BABYLON.Color4(0.2, 1.0, 0.5, 1);   // green origin
        const NODAL_ORIGIN_COLOR = new BABYLON.Color4(1.0, 0.67, 0.2, 1); // orange origin

        const NET_POINT_COLOR = new BABYLON.Color3(0.2, 1.0, 0.5);   // green dots
        const NODAL_POINT_COLOR = new BABYLON.Color3(1.0, 0.67, 0.2); // orange dots

        function buildStaticPoints(vectors, which) {
            // Dispose previous
            if (which === 'net') { if (netPointsMesh) { netPointsMesh.dispose(); netPointsMesh = null; } }
            else { if (nodalPointsMesh) { nodalPointsMesh.dispose(); nodalPointsMesh = null; } }

            const showThis = which === 'net' ? chkShowNetForces.checked : chkShowNodalLoads.checked;
            if (!showThis || vectors.length === 0) return;

            const ps = parseFloat(pointNumber.value);
            if (ps <= 0) return;

            const dotColor = which === 'net' ? NET_POINT_COLOR : NODAL_POINT_COLOR;

            const positions = [];
            const colors = [];
            for (const v of vectors) {
                if (!activeObjects.has(v.obj)) continue;
                positions.push(v.pos.x, v.pos.y, v.pos.z);
                colors.push(dotColor.r, dotColor.g, dotColor.b, 1);
            }
            if (positions.length === 0) return;

            const mesh = new BABYLON.Mesh(which + "Dots", scene);
            const vertexData = new BABYLON.VertexData();
            vertexData.positions = positions;
            vertexData.colors = colors;
            vertexData.applyToMesh(mesh);

            const mat = new BABYLON.StandardMaterial(which + "DotMat", scene);
            mat.pointsCloud = true;
            mat.pointSize = ps;
            mat.emissiveColor = dotColor;
            mat.disableLighting = true;
            mesh.material = mat;
            mesh.isPickable = false;

            if (which === 'net') netPointsMesh = mesh;
            else nodalPointsMesh = mesh;
        }

        function rebuildVectors(vectors, which) {
            // Dispose previous
            if (which === 'net') { if (netVectorMesh) { netVectorMesh.dispose(); netVectorMesh = null; } }
            else { if (nodalVectorMesh) { nodalVectorMesh.dispose(); nodalVectorMesh = null; } }

            const showThis = which === 'net' ? chkShowNetForces.checked : chkShowNodalLoads.checked;
            if (!showThis || vectors.length === 0) return;

            const scale = parseFloat(scaleNumber.value);
            const isLog = document.querySelector('input[name="scaleMode"]:checked').value === 'log';
            const axis = axisSelect.value;

            const cMin = parseFloat(vecColorMin.value);
            const cMax = parseFloat(vecColorMax.value);

            const dMin = bounds.min[axis];
            const dMax = bounds.max[axis];
            const dRange = dMax - dMin || 1;

            const userMin = (parseFloat(sliceMin.value) / 1000) * dRange + dMin;
            const userMax = (parseFloat(sliceMax.value) / 1000) * dRange + dMin;

            const originColor = which === 'net' ? NET_ORIGIN_COLOR : NODAL_ORIGIN_COLOR;

            const lines = [];
            const colors = [];

            for (const v of vectors) {
                if (!activeObjects.has(v.obj)) continue;
                const val = v.pos[axis];
                if (val < userMin || val > userMax) continue;

                let len = v.mag;
                if (isLog) len = Math.log(1 + v.mag);
                len *= scale;

                const colorTip = getRainbowColor4(v.mag, cMin, cMax);
                lines.push([v.pos, v.pos.add(v.dir.scale(len))]);
                colors.push([originColor, colorTip]);
            }

            if (lines.length > 0) {
                const mesh = BABYLON.MeshBuilder.CreateLineSystem(which + "Vec", { lines, colors }, scene);
                mesh.isPickable = false;
                if (which === 'net') netVectorMesh = mesh;
                else nodalVectorMesh = mesh;
            }
        }

        function updateSlicerPlanes(axis, valMin, valMax, visible) {
            if (!visible || !axis) {
                minPlane.isVisible = false;
                maxPlane.isVisible = false;
                return;
            }

            minPlane.isVisible = true;
            maxPlane.isVisible = true;

            const sizeX = (bounds.max.x - bounds.min.x) || 1;
            const sizeY = (bounds.max.y - bounds.min.y) || 1;
            const sizeZ = (bounds.max.z - bounds.min.z) || 1;
            const c = bounds.center;

            minPlane.rotationQuaternion = null;
            maxPlane.rotationQuaternion = null;
            minPlane.rotation = new BABYLON.Vector3(0, 0, 0);
            maxPlane.rotation = new BABYLON.Vector3(0, 0, 0);

            if (axis === 'z') {
                minPlane.scaling.x = sizeX; minPlane.scaling.y = sizeY;
                maxPlane.scaling.x = sizeX; maxPlane.scaling.y = sizeY;
                minPlane.position = new BABYLON.Vector3(c.x, c.y, valMin);
                maxPlane.position = new BABYLON.Vector3(c.x, c.y, valMax);
            } else if (axis === 'x') {
                minPlane.scaling.x = sizeZ; minPlane.scaling.y = sizeY;
                maxPlane.scaling.x = sizeZ; maxPlane.scaling.y = sizeY;
                minPlane.position = new BABYLON.Vector3(valMin, c.y, c.z);
                maxPlane.position = new BABYLON.Vector3(valMax, c.y, c.z);
                minPlane.rotation.y = Math.PI / 2;
                maxPlane.rotation.y = Math.PI / 2;
            } else if (axis === 'y') {
                minPlane.scaling.x = sizeX; minPlane.scaling.y = sizeZ;
                maxPlane.scaling.x = sizeX; maxPlane.scaling.y = sizeZ;
                minPlane.position = new BABYLON.Vector3(c.x, valMin, c.z);
                maxPlane.position = new BABYLON.Vector3(c.x, valMax, c.z);
                minPlane.rotation.x = Math.PI / 2;
                maxPlane.rotation.x = Math.PI / 2;
            }
        }

        // =================================================================
        //  9. STATUS
        // =================================================================
        function updateStats() {
            const parts = [];
            if (meshData) {
                let vis = 0;
                for (let i = 0; i < meshData.n_tri; i++) {
                    const objName = meshData.objectNames[meshData.objectIds[i] - 1];
                    if (activeObjects.has(objName)) vis++;
                }
                parts.push(`Surface: ${vis.toLocaleString()} / ${meshData.n_tri.toLocaleString()} tri`);
            }
            if (rawNetVectors.length > 0) {
                let vis = 0;
                for (const v of rawNetVectors) { if (activeObjects.has(v.obj)) vis++; }
                parts.push(`Net: ${vis.toLocaleString()} / ${rawNetVectors.length.toLocaleString()}`);
            }
            if (rawNodalVectors.length > 0) {
                let vis = 0;
                for (const v of rawNodalVectors) { if (activeObjects.has(v.obj)) vis++; }
                parts.push(`Nodal: ${vis.toLocaleString()} / ${rawNodalVectors.length.toLocaleString()}`);
            }
            if (allObjectNames.size > 1) {
                parts.push(`Obj: ${activeObjects.size}/${allObjectNames.size}`);
            }
            document.getElementById('stats').textContent = parts.length > 0 ? parts.join(' | ') : 'No files loaded.';
        }

        // =================================================================
        //  10. INTERACTION
        // =================================================================
        function getPick(x, y) {
            const hit = scene.pick(x, y);
            if (hit.hit) return hit.pickedPoint;
            const ray = scene.createPickingRay(x, y, BABYLON.Matrix.Identity(), scene.activeCamera);
            const dist = BABYLON.Vector3.Distance(scene.activeCamera.position, scene.activeCamera.target);
            return ray.origin.add(ray.direction.scale(dist));
        }

        canvas.addEventListener("pointerdown", (evt) => {
            if (evt.button === 2) {
                const target = getPick(evt.clientX, evt.clientY);
                const anim = new BABYLON.Animation("t", "target", 60, BABYLON.Animation.ANIMATIONTYPE_VECTOR3);
                anim.setKeys([{ frame: 0, value: scene.activeCamera.target }, { frame: 20, value: target }]);
                scene.beginDirectAnimation(scene.activeCamera, [anim], 0, 20);
                pivotMarker.position = target;
                pivotMarker.isVisible = true;
                const s = scene.activeCamera.radius * 0.03;
                pivotMarker.scaling = new BABYLON.Vector3(s, s, s);
            }
            if (evt.shiftKey && evt.button === 0) {
                isSelecting = true;
                startX = evt.clientX;
                startY = evt.clientY;
                scene.activeCamera.detachControl();
                selectionBox.style.display = "block";
                updateBox(startX, startY);
            }
        });

        let isSelecting = false;
        let startX = 0, startY = 0;

        canvas.addEventListener("pointermove", (evt) => {
            if (isSelecting) updateBox(evt.clientX, evt.clientY);
        });

        function updateBox(currX, currY) {
            selectionBox.style.left = Math.min(startX, currX) + 'px';
            selectionBox.style.top = Math.min(startY, currY) + 'px';
            selectionBox.style.width = Math.abs(startX - currX) + 'px';
            selectionBox.style.height = Math.abs(startY - currY) + 'px';
        }

        canvas.addEventListener("pointerup", (evt) => {
            if (isSelecting) {
                isSelecting = false;
                selectionBox.style.display = "none";
                scene.activeCamera.attachControl(canvas, true, false, 1);
                scene.activeCamera._panningMouseButton = 1;
                if (scene.activeCamera.inputs.attached.pointers)
                    scene.activeCamera.inputs.attached.pointers._panningMouseButton = 1;
                const w = Math.abs(evt.clientX - startX);
                const h = Math.abs(evt.clientY - startY);
                if (w > 10 && h > 10) performZoom(startX, startY, evt.clientX, evt.clientY, w, h);
            }
        });

        function performZoom(x1, y1, x2, y2, w, h) {
            const cx = (x1 + x2) / 2;
            const cy = (y1 + y2) / 2;
            const newTarget = getPick(cx, cy);
            let ratio = h / canvas.clientHeight;
            if (ratio < 0.02) ratio = 0.02;
            const newRadius = scene.activeCamera.radius * ratio;

            const animT = new BABYLON.Animation("t", "target", 60, BABYLON.Animation.ANIMATIONTYPE_VECTOR3);
            animT.setKeys([{ frame: 0, value: scene.activeCamera.target.clone() }, { frame: 30, value: newTarget }]);
            const animR = new BABYLON.Animation("r", "radius", 60, BABYLON.Animation.ANIMATIONTYPE_FLOAT);
            animR.setKeys([{ frame: 0, value: scene.activeCamera.radius }, { frame: 30, value: newRadius }]);
            scene.beginDirectAnimation(scene.activeCamera, [animT, animR], 0, 30);

            pivotMarker.position = newTarget;
            pivotMarker.isVisible = true;
            const s = newRadius * 0.03;
            pivotMarker.scaling = new BABYLON.Vector3(s, s, s);
        }
    </script>
</body>
</html>
