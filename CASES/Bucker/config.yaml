# ==============================================================================
# LBM SOLVER CONFIGURATION (D3Q27 WMLES - High Re Production Mode)
# ==============================================================================
# This file controls the physics, numerics, and geometry for the Lattice Boltzmann 
# simulation. It uses the D3Q27 velocity set with a WALE turbulence model and 
# Wall-Modeled Large Eddy Simulation (WMLES) capability.
#
# MASTER CONTROL
# ==============================================================================

# ##############################################################################
#                                 BASIC PARAMETERS
# ##############################################################################

basic:
  # --------------------------------------------------------------------------
  # INPUT GEOMETRY
  # --------------------------------------------------------------------------
  # The STL file defining the obstacle. 
  # IMPORTANT: The code looks for this file INSIDE your active case folder.
  stl_file: "bucker.stl"

  # Scale factor applied to the STL geometry vertices.
  # Use 0.001 if your STL is in millimeters but you want meters.
  # Use 1.0 if your STL is already in meters.
  stl_scale: 1.

  # [deg] Model rotation around Y axis (angle of attack).
  alpha: 0.0
  # [deg] Model rotation around Z axis (sideslip). Ignored when symmetric_analysis=true.
  beta: 0.0
  
  # --------------------------------------------------------------------------
  # MESH RESOLUTION
  # --------------------------------------------------------------------------
  # Determines the density of the grid.
  # "N" cells spanning the reference length.
  # Higher = More accurate, but RAM and Compute usage scale with N^3 and N^4 respectively.
  # For WMLES (Wall Modeled LES), target a first-cell y+ of 30-100.
  surface_resolution: 300
  
  # Number of grid refinement levels (Multi-grid).
  # 0 = AUTO-COMPUTE (Recommended). The solver calculates the number of levels needed
  #     to ensure the far-field boundaries are far enough away.
  # >0 = Manual override (e.g., set to 7 to force exactly 7 levels).
  num_levels: 7
  
  # --------------------------------------------------------------------------
  # REFERENCE VALUES (Required for Aerodynamic Coefficients)
  # --------------------------------------------------------------------------
  # These values are used solely for calculating Cl, Cd, Cm.
  # They do not affect the physics of the flow, only the post-processing numbers.
  
  # The planform area of the FULL geometry (even if simulating half).
  # [m²] used for Cd = Force / (0.5 * rho * U^2 * Area).
  # NOTE: If 'symmetric_analysis' is true, the solver automatically uses half this value.
  reference_area_of_full_model: 13.5
  
  # Mean Aerodynamic Chord (MAC) or characteristic length.
  # [m] used for Moment Coefficient (Cm = Moment / (Force * Chord)).
  reference_chord: 1.0
  
  # The length used to calculate the Reynolds number.
  # [m] Usually the chord length or body length.
  reference_length_for_meshing: 8
  
  # The dimension corresponding to the reference length in the STL file.
  # Options: "x", "y", "z". Usually "x" for flow aligned with X-axis.
  reference_dimension: "x"

  minimum_facet_size: 0.2   # [m] Max allowed triangle edge length. 0 = no subdivision.
    
  # --------------------------------------------------------------------------
  # PHYSICS
  # --------------------------------------------------------------------------
  fluid:
    # Air density at sea level (or your specific fluid). [kg/m³]
    density: 1.225
    
    # Kinematic Viscosity (nu = mu / rho). [m²/s]
    # Air ~ 1.5e-5. Water ~ 1.0e-6.
    kinematic_viscosity: 1.5e-5
  
  flow:
    # Free-stream inlet velocity in physical units [m/s].
    # This defines the Mach number and Reynolds number together with viscosity.
    velocity: 50.0

  simulation:
    # Total number of time steps to run.
    steps: 10000
    
    # Number of steps to ramp up the velocity from 0 to 'velocity'.
    # Crucial for stability. Sudden acceleration causes pressure shockwaves 
    # that can crash the simulation (NaNs). 
    # Recommended: 1000 to 5000.
    ramp_steps: 2000
    
    # How often to write full 3D VTK output files.
    # High frequency = huge disk usage.
    output_freq: 2500
    
    # Name of the folder where results will be saved (inside the case directory).
    output_dir: "RESULTS"

    # --------------------------------------------------------------------------
    # OUTPUT CONTROL
    # --------------------------------------------------------------------------
    # Select which fields to write to the VTK files.
    output_fields:
      density: true
      velocity: true
      velocity_magnitude: true
      vorticity: false
      obstacle: true
      level: true
      bouzidi: false

# ##############################################################################
#                                 ADVANCED PARAMETERS
# ##############################################################################

advanced:
  # --------------------------------------------------------------------------
  # LBM NUMERICS
  # --------------------------------------------------------------------------
  numerics:
    u_lattice: 0.03
    # Collision operator selection:
    #   "regularized_bgk" — Regularized BGK with WALE subgrid model (default)
    #   "cumulant"         — Cumulant collision operator (D3Q27)
    collision_operator: "cumulant"
    c_wale: 0.50
    tau_min: 0.500001
    tau_safety_factor: 1.0
    inlet_turbulence_intensity: 0.0
    nu_sgs_background: 0.0
    sponge_blend_distributions: false
    compressibility_correction: false

    # ── Phase 2: Cumulant-specific parameters ──
    # Only used when collision_operator is "cumulant".
    cumulant:
      # 2A — Configurable relaxation rates
      omega_bulk: 1.0        # Bulk viscosity (trace of 2nd-order normal stress)
      omega_3: 1.0           # 3rd-order cumulants (energy flux)
      omega_4: 1.0           # 4th-order cumulants (base value)

      # 2B — Geier (2017) adaptive 4th-order relaxation
      adaptive_omega_4: true  # Enable adaptive ω₄ for diagonal cumulants
      lambda_param: 0.1667    # Λ parameter (1/6). Controls limiter aggressiveness.
                              # Smaller Λ → more aggressive stabilization.
                              # Typical: 1/6 (0.1667) or 1/12 (0.0833)

      # 2C — Cumulant limiters for high-Re stability
      #   "none"       — No limiter (fastest, least stable)
      #   "factored"   — Cauchy-Schwarz realizability on 2nd-order cumulants
      #   "positivity" — Post-collision positivity enforcement (most robust)
      limiter: "factored"
  
  # --------------------------------------------------------------------------
  # HIGH REYNOLDS NUMBER OPTIONS
  # --------------------------------------------------------------------------
  high_re:
    # If true, the solver adjusts 'num_levels' automatically to ensure 
    # the simulation fits in memory and maintains stability.
    # Set to 'false' if you manually set 'num_levels' in 'basic' settings.
    auto_levels: false
    
    # Maximum allowed levels when using auto-detection.
    # Limits VRAM usage.
    max_levels: 12
    
    # Minimum number of blocks required in the coarsest level.
    # Ensures the far-field domain isn't too small.
    min_coarse_blocks: 4
    
    # WALL MODEL (Equilibrium Stress Model)
    # Essential for High Re flows where the boundary layer is too thin 
    # to resolve directly (y+ > 10).
    wall_model:
      enabled: true               # true = Activate Wall Model.
      type: "equilibrium"         # Currently supports "equilibrium" (Spalding/Log-law).
      y_plus_target: 100.0        # Target y+ for the first cell center (approximate).
      
    # Adaptive Mesh Refinement (AMR) - Placeholder for future use.
    adaptive_refinement:
      enabled: false
      criterion: "vorticity"
      threshold: 0.1
  
  # --------------------------------------------------------------------------
  # DOMAIN SIZING
  # --------------------------------------------------------------------------
  # All values are multiples of 'reference_length'.
  domain:
    upstream: 2.        # Space in front of the object.
    downstream: 2.5       # Space behind the object (wake region).
    lateral: 2.         # Space to the sides.
    height: 2.          # Space above/below.
    
    # Thickness of the viscosity sponge layer at boundaries (absorbs reflections).
    # Fraction of domain size (0.10 = 10%).
    sponge_thickness: 0.10
  
  # --------------------------------------------------------------------------
  # MESH REFINEMENT
  # --------------------------------------------------------------------------
  refinement:
    # Size of a grid block in cells (NxNxN).
    # 8 is standard for GPU efficiency (memory coalescing).
    block_size: 8
    
    # How many buffer blocks to keep around the geometry at each level.
    # Prevents high-velocity flow from exiting a fine grid too quickly.
    margin: 2
    
    # Refinement strategy.
    # "geometry_first" = Checks intersection with STL triangles directly (Robust).
    strategy: "geometry_first"
    
    # If true, assumes symmetry plane at Y=0.
    # Reduces domain size by half. Boundary condition at Y=0 becomes slip/symmetry.
    symmetric_analysis: true
    
    # Wake refinement zone (Box behind the object).
    # Forces high resolution in the wake to capture vortices.
    wake_enabled: false
    
    # Wake dimensions (relative to reference_length)
    wake_length: 0.25
    wake_width_factor: 0.1
    wake_height_factor: 0.1
  
  # --------------------------------------------------------------------------
  # BOUNDARY CONDITIONS
  # --------------------------------------------------------------------------
  boundary:
    # Method for fluid-solid interaction.
    # "bounce_back" = staircase approximation (1st order). Fast, robust.
    # "bouzidi" = interpolated bounce-back (2nd order). Accurate geometry, higher noise.
    method: "bouzidi"
    
    # How many levels (starting from finest) use the high-accuracy Bouzidi method.
    # Usually 1 (finest level only) is sufficient.
    bouzidi_levels: 1
    
    # Store Q-values (distances) in Float16 to save VRAM.
    use_float16_qmap: true
    
    # Threshold for treating a cell as fluid vs solid in Bouzidi interpolation.
    q_min_threshold: 0.001
  
  # --------------------------------------------------------------------------
  # FORCE/MOMENT COMPUTATION
  # --------------------------------------------------------------------------
  forces:
    enabled: true                 # Calculate Lift/Drag/Moment?
    output_freq: 0                # 0 = Matches diagnostics frequency.
    
    # Point about which aerodynamic moments (Cm) are calculated.
    # Normalized coordinates [x/Chord, y/Span, z/Thickness] relative to geometry origin.
    # [0.25, 0.0, 0.0] is standard Quarter-Chord.
    moment_center: [0.25, 0.0, 0.0]

    # Export two-sided net force per triangle (CSV + VTK)
    net_force_export: true
  
  # --------------------------------------------------------------------------
  # DIAGNOSTICS
  # --------------------------------------------------------------------------
  diagnostics:
    # Frequency (in steps) to print status to console and write CSV logs.
    freq: 100
    
    # Check for NaNs or exploding velocities at every diagnostic step.
    stability_check: true
    
    # Print warning if Tau < 0.51 (approaching instability).
    print_tau_warning: true
  
  # --------------------------------------------------------------------------
  # GPU OPTIMIZATION
  # --------------------------------------------------------------------------
  gpu:
    # How many time steps to queue on the GPU before syncing with CPU.
    # Higher = Faster, but less responsive to interrupts.
    async_depth: 8
    
    # Use CUDA Streams for concurrent kernel execution (if applicable).
    use_streams: true
    
    # Optimization for memory access patterns.
    prefetch_neighbors: true